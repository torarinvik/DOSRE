using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace DOSRE.Dasm;

public static class Bin16Mc1Structurer
{
    // Matches the same label set as MC0/MC2 (with optional leading '}' fragments from prior lowering).
    private static readonly Regex LabelOnlyRx = new Regex(
        @"^\s*(?:}\s*)*(?<label>[A-Za-z_.$@?][A-Za-z0-9_.$@?]*)\s*:\s*(?://.*)?$",
        RegexOptions.Compiled);

    public static string StructureMc1AsMc2Blocks(string mc1Path)
    {
        if (string.IsNullOrWhiteSpace(mc1Path)) throw new ArgumentException("mc1Path is required", nameof(mc1Path));
        if (!File.Exists(mc1Path)) throw new FileNotFoundException("MC1 file not found", mc1Path);

        var mc1 = Mc1.Parse(mc1Path);
        return StructureMc1AsMc2Blocks(mc1);
    }

    public static string StructureMc1AsMc2Blocks(Mc1.Mc1File mc1)
    {
        if (mc1 == null) throw new ArgumentNullException(nameof(mc1));

        var sb = new StringBuilder();
        sb.AppendLine("// MC2 (structured) generated by DOSRE");
        if (!string.IsNullOrWhiteSpace(mc1.Source)) sb.AppendLine($"// source: {mc1.Source}");
        sb.AppendLine("// note: 'block/if/while' wrappers are presentation-only in PreserveBytes mode");
        sb.AppendLine();

        // Emit declarations deterministically, but keep the original intent.
        foreach (var kv in mc1.Consts.OrderBy(k => k.Key, StringComparer.Ordinal))
        {
            var v = kv.Value;
            sb.AppendLine($"const {kv.Key}: {v.Type} = 0x{v.Value:X4};");
        }
        if (mc1.Consts.Count > 0) sb.AppendLine();

        foreach (var kv in mc1.Types.OrderBy(k => k.Key, StringComparer.Ordinal))
        {
            // Skip built-ins to avoid re-declaring farptr16 everywhere.
            if (string.Equals(kv.Key, "farptr16", StringComparison.Ordinal))
                continue;

            var st = kv.Value;
            var fields = string.Join("  ", st.Fields.Select(f => $"{f.Name}: {f.Type};"));
            sb.AppendLine($"type {st.Name} = struct {{ {fields} }};");
        }
        if (mc1.Types.Count > 1) sb.AppendLine();

        foreach (var kv in mc1.Views.OrderBy(k => k.Key, StringComparer.Ordinal))
        {
            var v = kv.Value;
            sb.AppendLine($"view {v.Name} at ({v.SegExpr}, {v.OffExpr}) : {v.Type};");
        }
        if (mc1.Views.Count > 0) sb.AppendLine();

        // Wrap the MC1 statement stream into named blocks without changing order.
        // This is a pure presentation change; MC2 desugaring strips blocks to comments.
        var pending = new List<string>();
        string currentBlockName = null;

        void FlushBlock()
        {
            if (pending.Count == 0) return;
            var name = string.IsNullOrWhiteSpace(currentBlockName) ? "_entry" : currentBlockName;
            sb.AppendLine($"block {name} {{");
            foreach (var l in pending)
                sb.AppendLine(l);
            sb.AppendLine("}");
            sb.AppendLine();
            pending.Clear();
        }

        for (var i = 0; i < mc1.Statements.Count; i++)
        {
            var line = mc1.Statements[i] ?? string.Empty;
            var m = LabelOnlyRx.Match(line);
            if (m.Success)
            {
                // Start a new block at each label.
                FlushBlock();
                currentBlockName = m.Groups["label"].Value;
                pending.Add(line); // keep the label itself inside the block for readability
                continue;
            }

            pending.Add(line);
        }

        FlushBlock();
        return sb.ToString();
    }
}
