using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace DOSRE.Dasm;

public static class Bin16Mc1Structurer
{
    // Matches the same label set as MC0/MC2 (with optional leading '}' fragments from prior lowering).
    private static readonly Regex LabelOnlyRx = new Regex(
        @"^\s*(?:}\s*)*(?<label>[A-Za-z_.$@?][A-Za-z0-9_.$@?]*)\s*:\s*(?://.*)?$",
        RegexOptions.Compiled);

    private static readonly Regex IfGotoRx = new Regex(
        @"^\s*if\s*\(\s*(?<cond>.*?)\s*\)\s*goto\s+(?<lbl>[A-Za-z_.$@?][A-Za-z0-9_.$@?]*)\s*;\s*//\s*@",
        RegexOptions.Compiled | RegexOptions.IgnoreCase);

    private static readonly Regex ElseGotoRx = new Regex(
        @"^\s*else\s+goto\s+(?<lbl>[A-Za-z_.$@?][A-Za-z0-9_.$@?]*)\s*;\s*//\s*@",
        RegexOptions.Compiled | RegexOptions.IgnoreCase);

    private static readonly Regex ElseGotoPrefixRx = new Regex(
        @"^(?<indent>\s*)else\s+goto\s+",
        RegexOptions.Compiled | RegexOptions.IgnoreCase);

    private static readonly Regex GotoRx = new Regex(
        @"^\s*goto\s+(?<lbl>[A-Za-z_.$@?][A-Za-z0-9_.$@?]*)\s*;\s*//\s*@",
        RegexOptions.Compiled | RegexOptions.IgnoreCase);

    public enum StructureMode
    {
        Preserve,
        Canonical,
    }

    public static string StructureMc1AsMc2Blocks(string mc1Path, StructureMode mode = StructureMode.Preserve)
    {
        if (string.IsNullOrWhiteSpace(mc1Path)) throw new ArgumentException("mc1Path is required", nameof(mc1Path));
        if (!File.Exists(mc1Path)) throw new FileNotFoundException("MC1 file not found", mc1Path);

        var mc1 = Mc1.Parse(mc1Path);
        return StructureMc1AsMc2Blocks(mc1, mode);
    }

    public static string StructureMc1AsMc2Blocks(Mc1.Mc1File mc1, StructureMode mode = StructureMode.Preserve)
    {
        if (mc1 == null) throw new ArgumentNullException(nameof(mc1));

        var sb = new StringBuilder();
        sb.AppendLine("// MC2 (structured) generated by DOSRE");
        if (!string.IsNullOrWhiteSpace(mc1.Source)) sb.AppendLine($"// source: {mc1.Source}");
        sb.AppendLine("// note: 'block/if/while' wrappers are presentation-only in PreserveBytes mode");
        sb.AppendLine();

        // Emit declarations deterministically, but keep the original intent.
        foreach (var kv in mc1.Consts.OrderBy(k => k.Key, StringComparer.Ordinal))
        {
            var v = kv.Value;
            sb.AppendLine($"const {kv.Key}: {v.Type} = 0x{v.Value:X4};");
        }
        if (mc1.Consts.Count > 0) sb.AppendLine();

        foreach (var kv in mc1.Types.OrderBy(k => k.Key, StringComparer.Ordinal))
        {
            // Skip built-ins to avoid re-declaring farptr16 everywhere.
            if (string.Equals(kv.Key, "farptr16", StringComparison.Ordinal))
                continue;

            var st = kv.Value;
            var fields = string.Join("  ", st.Fields.Select(f => $"{f.Name}: {f.Type};"));
            sb.AppendLine($"type {st.Name} = struct {{ {fields} }};");
        }
        if (mc1.Types.Count > 1) sb.AppendLine();

        foreach (var kv in mc1.Views.OrderBy(k => k.Key, StringComparer.Ordinal))
        {
            var v = kv.Value;
            sb.AppendLine($"view {v.Name} at ({v.SegExpr}, {v.OffExpr}) : {v.Type};");
        }
        if (mc1.Views.Count > 0) sb.AppendLine();

        // Wrap the MC1 statement stream into named blocks without changing order.
        // This is a pure presentation change; MC2 desugaring strips blocks to comments.
        var pending = new List<string>();
        string currentBlockName = null;

        void FlushBlock()
        {
            if (pending.Count == 0) return;
            var name = string.IsNullOrWhiteSpace(currentBlockName) ? "_entry" : currentBlockName;
            sb.AppendLine($"block {name} {{");
            foreach (var l in pending)
                sb.AppendLine(l);
            sb.AppendLine("}");
            sb.AppendLine();
            pending.Clear();
        }

        for (var i = 0; i < mc1.Statements.Count; i++)
        {
            var line = mc1.Statements[i] ?? string.Empty;
            var m = LabelOnlyRx.Match(line);
            if (m.Success)
            {
                // Start a new block at each label.
                FlushBlock();
                currentBlockName = m.Groups["label"].Value;
                pending.Add(line); // keep the label itself inside the block for readability
                continue;
            }

            // Canonical: wrap common if/else-goto patterns into MC2 if/else blocks.
            // This is presentation-only: it keeps the original origin-tagged statements intact.
            if (mode == StructureMode.Canonical)
            {
                var ifm = IfGotoRx.Match(line);
                if (ifm.Success)
                {
                    var cond = ifm.Groups["cond"].Value.Trim();
                    var indentLen = line.Length - line.TrimStart().Length;
                    var indent = indentLen > 0 ? line.Substring(0, indentLen) : string.Empty;
                    var next = (i + 1) < mc1.Statements.Count ? (mc1.Statements[i + 1] ?? string.Empty) : string.Empty;
                    var elsem = ElseGotoRx.Match(next);

                    var gotom = GotoRx.Match(next);

                    if (elsem.Success)
                    {
                        var normalizedElse = ElseGotoPrefixRx.Replace(next, "${indent}goto ");
                        pending.Add($"{indent}if ({cond}) {{");
                        pending.Add($"{indent}  {line.TrimStart().TrimEnd()}");
                        pending.Add($"{indent}}} else {{");
                        pending.Add($"{indent}  {normalizedElse.TrimStart().TrimEnd()}");
                        pending.Add($"{indent}}}");
                        i++; // consumed else line
                        continue;
                    }

                    // Implicit else: decompiler sometimes emits `if (...) goto L;` then `goto M;` (unconditional)
                    // rather than an explicit `else goto M;`.
                    if (gotom.Success)
                    {
                        pending.Add($"{indent}if ({cond}) {{");
                        pending.Add($"{indent}  {line.TrimStart().TrimEnd()}");
                        pending.Add($"{indent}}} else {{");
                        pending.Add($"{indent}  {next.TrimStart().TrimEnd()}");
                        pending.Add($"{indent}}}");
                        i++; // consumed goto line
                        continue;
                    }

                    pending.Add($"{indent}if ({cond}) {{");
                    pending.Add($"{indent}  {line.TrimStart().TrimEnd()}");
                    pending.Add($"{indent}}}");
                    continue;
                }
            }

            pending.Add(line);
        }

        FlushBlock();
        return sb.ToString();
    }
}
